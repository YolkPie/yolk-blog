---
title: 咚咚聊天通信实践
date: 2020-10-13 17:57:54
tags:
  - 小程序
categories: 小程序
keywords: 小程序
description: 虚拟DOM的核心之一就是它的Diff算法，其中最为核心的就是核心Diff算法，只有在新旧虚拟DOM的子节点都是多个的时候，核心Diff算法才会派上用场。
cover: https://img12.360buyimg.com/imagetools/jfs/t1/153539/38/2109/32094/5f859c71Ea6de9fb8/7ca42e0d3981905f.jpg
top_img: https://img13.360buyimg.com/imagetools/jfs/t1/141779/13/10654/15022/5f859d02E78c5a402/effb7070752ffffe.jpg
---
### 咚咚聊天通信实践


前言：

京东咚咚通信基于websocket实现双向通信，是在socket基础上进行封装。所以做过socket通信的人，对咚咚不用畏惧，其原理一致，咚咚使用起来功能更多，更简单，使用步骤即引入js,封装好的js会暴露给我们一些API，直接使用其方法就可以实现通信。
本文章主要介绍咚咚使用功能，功能方法处理，注意事项等。

1. 创建组群
2. 建立通信
3. 监听事件
4. 拉取历史信息
5. 展示页面
6. 优化功能及注意事项

应用场景：

项目应用场景比较多，医药的医患通信、律师的用户咨询、法院的咨询等等。


### 创建组群-createGroup

API提供了创建组群的方法，但是这一步骤均是由后端创建，然后返回前端聊天群组的ID，前端通过ID拉取聊天信息及建立独立通信。但是在开发之前，经常需要前端自己通过API创建群里，实现后续聊天功能。联调时调用后端创建群组。

1.	创建群组需要在建立通信之后，这也是我比较好奇的一点，这里的建立通信实际上指建立连接connect,这里获取了用户的pin及用户要使用的角色，登录的app,准备建立连接的tochat用户。获取基本信息后，基于此建立群组ID.
2.	建立群组ID之后要记录此ID，因为之后的发消息及接受消息，拉取记录都是基于此ID，一个用户可以创建多个群组，分别有不同的ID。
``` js
sdk.createGroup({
        'gid': 1111,//"群组id（更新必填）
        'name': '群test',
        'nickName': 'aaa',
        'intro': '群组介绍test',
        'notice': '群公告group notice',
        'approvalRule': 'identity',
        'sCode': '',
        'avatar': '群自定义头像',
        'modifyFiled': 1,//创建群
        'canSearch': 1,//1能，0不能被搜索到
        'max': 5, //群人数
        'kind': 1024, //群类型：(数字型), 512:内部群，1024:外部群；上行不填,服务器根据成员app赋值;
        'invitation': '邀请语hi join us',
        'invitees': [
          { 'pin': 'aaa', 'app': 'ee', 'nickName':'咚咚'},
          { 'pin': '@im.jd.com', 'app': 'jd.waiter', 'nickName':'京东客服'}
        ],
        'bizExt': {
          'accessType': ''
        }
      }, function (pack) {
      })
```

### 建立通信-connect

1.	建立连接之前，一定要登录账号，因为建立连接需要验证登录态，使用京东账号登录即可，但是此处需要创建连接的账号和登录账号一致。
2.	查看是否建立成功：
a.	打开控制台，查看网络连接，会有上行和下行两个消息，上行为发送的请求，下行为返回的请求结果。
b.	连接每30s会发送一次心跳以确认连接没有中断。此处可通过心跳监听通信连接情况

``` js
this.chatConfig = {
      pin: 'aaa',//当前登录用户的身份ID
      appId: 'open.5478494bd9d948.cc',//当前登录用户角色
      toChat: '@im.jd.com',//和谁建立聊天？对方的身份ID(单人或群聊)
      toAppId: 'jd.waiter',//对方的登录角色
      clientType: 'm',//客户端类型，常量，可选值：m（移动WEB）/comet（PC WEB）/android（安卓客户端）/iOS（iOS客户端）
      //SDK链接的Websocket服务地址，默认为ws://ws0-dd.jd.com(内网可访问)。生产环境Websocket地址请咨询服务端获取
    }

sdk.connect(this.chatConfig, (socket) => {
      sdk.on('open', function (data) {
        this_.showLoading = false
      })
      sdk.on('message', this_.onMessage)
      sdk.on('chat_message_ack', function (data) {
        console.log(data,'发送成功已读chat_message_ack')
      })
    }, this.groupId)
```


### 监听事件

1.	事件监听需要在建立连接之后，监听事件包括：消息发送及返回、连接关闭、连接建立；
2.	监听到连接建立之后可以写一些提示用户信息的逻辑，开始计时、发送默认信息等操作。
3.	监听关闭之后，可以停止计时，发送提醒用户连接已经中断等操作。
4.	监听消息返回及发送，之后操作比较多，包括角色的处理安放、图片的处理、特殊类型接收后做特殊提示处理及展示。通信主要功能在此函数中实现。

### 拉取历史信息

1. 历史信息拉取回来处理和消息处理是使用一个函数，此处多了分页拉取。
2. 分页拉取是记录当前拉取最后一个消息的id,然后再次调用拉取消息函数，传入此id,会返回此id之前的10条记录。每次拉取条数由入参控制，最初拉取消息的入参id为-1.消息会返回总条数，是否还有上一页等消息。

``` js
sdk.pullHistoryMsg(this.startMid, this.pullCount, (res) => {}, this.groupId)

handleHistoryResult (res) {
      this.pullHistoryLoading = false
      if (res.msgs && res.msgs.length) {
        let historyList = res.msgs
        // 保存mid
        const _mid = historyList[historyList.length - 1].mid
        // 更新消息对应角色
        const { chatList } = this.datacon

        if (chatList.length) {
          this.scrollToId = chatList[0].id
        }
        for (let i = 0; i < historyList.length; i++) {
          let msgItemPush = this.combineRolesToMsg(historyList[i])
          if (msgItemPush) {
            chatList.unshift(msgItemPush)
          }
        }

        if (res.end) {
          this.hasMoreHistory = false
        } else {
          this.hasMoreHistory = true
        }
        this.startMid = _mid
        this.datacon.chatList = chatList
        console.log(chatList)
        this.scrollToChatItem(this.scrollToId)
      } else {
        // 没有更多历史消息
        this.hasMoreHistory = false
      }
    }
```

### 展示页面

1.图片处理
a. 图片的上传依赖后端服务器，当前咚咚没有提供图片上传地址，需要将本地选择的图片上传至自己服务器，然后再使用咚咚的发送图片API出入url,接收消息返回结果，此处返回图片的路径，大小、发送成功的时间戳、发送者等信息，然后做角色区分展示。

``` js
sendImage (file) {
      // sdk.sendImageMsg({url:'https://img11.360buyimg.com/ddimg/jfs/t6436/303/516091211/296860/207778b9/594126c0Nfd1dcd58.png',size:1000}, (message) => {}, this.groupId)

      // 老的浏览器可能根本没有实现 mediaDevices，所以我们可以先设置一个空的对象
      if (navigator.mediaDevices === undefined) {
        navigator.mediaDevices = {};
      }
      if (navigator.mediaDevices.getUserMedia === undefined) {
        navigator.mediaDevices.getUserMedia = function (constraints) {
          // 首先，如果有getUserMedia的话，就获得它
          var getUserMedia = navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia;

          // 一些浏览器根本没实现它 - 那么就返回一个error到promise的reject来保持一个统一的接口
          if (!getUserMedia) {
            return Promise.reject(new Error('getUserMedia is not implemented in this browser'));
          }

          // 否则，为老的navigator.getUserMedia方法包裹一个Promise
          return new Promise(function (resolve, reject) {
            getUserMedia.call(navigator, constraints, resolve, reject);
          });
        }
      }

      const constraints = {
        video: true,
        audio: false
      };
      let videoPlaying = false;
      let v = document.getElementById('video');
      let promise = navigator.mediaDevices.getUserMedia(constraints);
      promise.then(stream => {
        // 旧的浏览器可能没有srcObject
        if ("srcObject" in v) {
          v.srcObject = stream;
        } else {
          // 防止再新的浏览器里使用它，应为它已经不再支持了
          v.src = window.URL.createObjectURL(stream);
        }
        v.onloadedmetadata = function (e) {
          v.play();
          videoPlaying = true;
        };
      }).catch(err => {
        console.error(err.name + ": " + err.message);
      })
      if (videoPlaying) {
        let canvas = document.getElementById('canvasphoto');
        canvas.width = v.videoWidth;
        canvas.height = v.videoHeight;
        canvas.getContext('2d').drawImage(v, 0, 0);
        let data = canvas.toDataURL('image/webp');
        document.getElementById('photo').setAttribute('src', data);
      }
    },
``` 

2.文本处理
a.	文本消息返回有角色和发送时间、文本消息等内容，直接展示就可以。
3.	特殊类型处理
a.	特殊类型是通信间的一种特殊通信模式，主要处理非正常文本展示的场景，例如点击某按钮发送订单链接、发送特殊标识，都可以使用发送空消息，但是type给予事先约定好的字符串即可，拿到相应type字符串，做相应前端处理即可。


### 优化功能及注意事项

1. 消息通信必须建立连接
2. 图片上传需要自己服务器
3. 消息发送失败后处理，决定是否需要重新发送
4. 消息撤回复制等功能可以参考具体文档
5. 未读消息数量、用户是否已读、发送成功后页面自动滚动至最新信息处等功能需要前端自己处理，咚咚文档没有封装。

