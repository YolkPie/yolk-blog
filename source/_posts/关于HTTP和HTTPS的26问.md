---
title: 关于HTTP和HTTPS的26问
date: 2021-03-25 19:33:00
author: zjk537
tags:
- Q&A
cover: https://m.360buyimg.com/img/jfs/t1/175577/38/365/17811/605ca627Eeea89c4a/f7226d631cf20865.jpg
---

Web前端就是当用户在浏览器地址栏中输入一行字母看到的页面结果。然而，从输入字母到看到页面中都发生了什么，数据是怎么得到的？这些都离不开HTTP/HTTPS。

### HTTP与HTTPS有什么联系？它们的端口号是多少？
HTTP通常承载于TCP之上，在HTTP和TCP之间添加一个安全协议层（SSL或TSL），这个时候，就成了我们常说的HTTPS。HTTP默认的端口号为80，Https默认的端口号为443。
### 为什么 HTTPS更安全？
在网络请求中，需要有很多服务器、路由器的转发。其中的节点都可能篡改信息，而如果使用HTTPS，密钥在终点站才有。HTTPS之所以比HTTP安全，是因为它利用 SSL/TLS协议传输。它包含证书、卸载、流量转发、负载均衡、页面适配、浏览器适配、 refer传递等技术，保障了传输过程的安全性。
### 关于HTTP/2你知道多少？
HTTP/2引入了“服务器端推送”（server  push）的概念，它允许服务器端在客户端需要数据之前主动将数据发送到客户端缓存中，从而提高性能。
HTTP/2提供更多的加密支持。
HTTP2使用多路技术，允许多个消息在一个连接上同时交差。
它增加了头压缩（ header compression），因此请求非常小，请求和响应的 header都只会占用很小的带宽比例。
### 说出你知道的HTTP常见状态码。
（1）100 Continue表示继续，一般在发送post请求时，已发送了 HTTP header之后，服务器端将返回此信息，表示确认，之后发送具体参数信息。
（2）200 OK表示正常返回信息
（3）201 Created表示请求成功并且服务器创建了新的资源。
（4）202 Accepted表示服务器已接受请求，但尚未处理。
（5）301 Moved Permanently表示请求的网页已永久移动到新位置。
（6）302 Found表示临时性重定向。
（7）303 See Other表示临时性重定向，且总是使用GET请求新的URI。
（8）304 Not Modified表示自从上次请求后，请求的网页未修改过，
（9）400 Bad Request表示服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求。
（10）401 Unauthorized表示请求未授权。
（11）403 Forbidden表示禁止访问。
（12）404 Not Found表示找不到如何与URI相匹配的资源。
（13）500 Internal Server error表示最常见的服务器端错误。
（14）503 Service Unavailable表示服务器端暂时无法处理请求（可能是过载或维护）。
### 完整的HTTP事务流程是怎样的？
基本流程如下。
（1）域名解析。
（2）发起TCP的3次握手。
（3）建立TCP连接后发起HTTP请求。
（4）服务器端响应HTTP请求，浏览器得到HTML代码。
（5）浏览器解析HTML代码，并请求HTML代码中的资源。
（6）浏览器对页面进行渲染并呈现给用户。
### 实现一个简单的HTTP服务器。
在Node.js中加载HTTP模块，并创建服务器，监听端口代码。
```js
var  http = require（'http'）；//加载HTTP模块
http.createServer(function(req,res) { 
  res.writeHead(200，{' Content-Type'：'text/htm1'})；
  //200代表状态成功，文档类型是
  //给浏览器识别用的
  res.write（'< meta charset="UTF-8"><h1>有课前端网</h1>1'）；
  //返回给客户端的HTML数据
  res.end ()；
  //结束输出流
})
http.listen（3000）；//绑定3000
```
### 什么是HTTP？
HTTP是客户端和服务器端之间数据传输的格式规范，表示“超文本传输协议”。
### 什么是HTTP无状态协议？如何克服HTTP无状态协议的缺陷？
（1）无状态协议对于事务处理没有记忆能力。缺少状态意味着如果后续需要处理，需要前面提供的信息。
（2）克服无状态协议缺陷的办法是通过 cookie和会话保存信息。
### HTTP的请求报文和响应报文包含哪些部分？
请求报文包含3部分。
（1）请求行，包含请求方法、URI、HTTP版本信息。
（2）请求首部字段。
（3）请求内容实体。
响应报文包含3部分。
（1）状态行，包含HTTP版本、状态码、状态码的原因短语。
（2）响应首部字段。
（3）响应内容实体。
### HTTP中有哪些请求方式？
（1）GET：请求访问已经被URI（统一资源标识符）识别的资源，可以通过URL，给服务器传递参数数据
（2）POST：传输信息给服务器，主要功能与GET方法类似，但传递的数据量通常不受限制。
（3）PUT：传输文件，报文主体中包含文件内容，保存到对应URI位置。
（4）HEAD：获得报文首部，与GET方法类似，只是不返回报文主体，一般用于验证URI是否有效。
（5） DELETE：删除文件，与PUT方法相反，删除对应URL位置的文件。
（6）OPTIONS：查询相应URI支持的HTTP方法。
### HTTP协议中1.0版本规范与1.1版本规范的区别是什么？
在HTTP1.0中，当建立连接后，客户端发送一个请求，服务器端返回一个信息后就关闭连接，当浏览器下次请求的时候又要建立连接。显然，这种不断建立连接的方式会造成很多问题。
在HTTP1.1中，引入了持续连接的概念。通过这种连接，浏览器可以在建立一个连接之后，发送请求并得到返回信息，然后继续发送请求再次等到返回信息。也就是说，客户端可以连续发送多个请求，而不用等待每一个响应的到来。
### HTTP的首部字段包括哪些类型？
（1）通用首部字段（请求报文与响应报文都会使用的首部字段）。
> Date：创建报文的时间
Connection：连接的管理
Cache-Control：缓存的控制
Transfer-Encoding：报文主体的传输编码方式

（2）请求首部字段（请求报文会使用的首部字段）。
> Host：请求资源所在服务器。
Accept：可处理的媒体类型。
Accept-Charset：可接受的字符集。
Accept-Encoding：可接受的内容编码。
Accept-Language：可接受的自然语言。

（3）响应首部字段（响应报文会使用的首部字段）。
> Accept-Ranges：可接受的字节范围。
Location：令客户端重新定向到的URL。
Server : HTTP服务器的安装信息

（4）实体首部字段（请求报文与响应报文的实体部分使用的首部字段）。
> Allow：资源可支持的HTTP方法。
Content-Type：实体主体的类型。
Content-Encoding：实体主体使用的编码方式。
Content-Language：实体主体的自然语言。
Content-Length：实体主体的字节数。
Content-Range：实体主体的位置范围，一般用于发出部分请求时使用。

### 与HTTPS相比，HTTP有什么缺点？
HTTP的缺点如下。
（1）通信使用明文，不加密，内容可能被窃听，也就是被抓包分析。
（2）不验证通信方身份，可能遭到伪装。
（3）无法验证报文完整性，可能被篡改。
HTTPS就是HTTP+加密处理（一般是SSL安全通信线路）+认证+完整性保护。
### 如何优化HTTP请求？
利用负载均衡优化和加速HTTP应用请求；利用HTTP缓存来优化网站请求。
### HTTP协议有哪些特征？
支持客户端/服务器模式，简单快速，灵活，无连接，无状态。
### HTTP1.1版本的新特性有哪些？
新特性如下所示。
（1）默认持久连接，节省通信量，只要客户端服务端中任意一端没有明确指出断开TCP连接，就一直保持连接，可以多次发送HTTP请求。
（2）管线化，客户端可以同时发出多个HTTP请求，而不用一个个等待响应。
（3）断点续传原理。
### 说说TCP传输的三次握手、四次挥手策略。
为了准确无误地把数据送达目标处，TCP采用了三次握手策略。用TCP把数据包发送出去后，TCP不会对传送后的数据置之不理，它一定会向对方确认是否成功送达。握手过程中使用了TCP的标志，即SYN和ACK。
发送端首先给接收端发送一个带SYN标志的数据包。接收端收到后，回传一个带有SYN/ACK标志的数据包以表示正确传达，并确认信息。最后，发送端再回传一个带ACK标志的数据包，代表“握手”结東。若在握手过程中的某个阶段莫名中断，TCP会再次以相同的顺序发送相同的数据包。
断开一个TCP连接则需要“四次握手”。
第一次握手：主动关闭方发送一个FIN，用来关闭主动关闭方到被动关闭方的数据传送，也就是主动关闭方告诉被动关闭方，主动关闭方已经不会再给被动关闭方发送数据了（当然，在FIN包之前发送出去的数据，如果没有收到对应的ACK确认报文主动关闭方依然会重发这些数据），但是，此时主动关闭方还可以接收数据。
第二次握手：被动关闭方收到FIN包后，给对方发送一个ACK，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号）。
第三次握手：被动关闭方发送一个FIN，用来关闭被动关闭方到主动关闭方的数据传送，也就是告诉主动关闭方，被动关闭方的数据也发送完了，不会再给主动关闭方发送数据了。
第四次握手：主动关闭方收到FIN后，给被动关闭方发送一个ACK，确认序号为收到序号+1，至此，完成四次握手。
### 说说TCP和UDP的区别。
TCP（ Transmission control protocol，传输控制协议）是基于连接的协议，也就是说，在正式收发数据前，必须和对方建立可靠的连接。一个TCP连接必须要经过3次“对话”才能建立起来。
UDP（ User Datagram Protocol，用户数据报协议）是与TCP相对应的协议。它是面向非连接的协议，它不与对方建立连接，而是直接就把数据包发送过去。UDP适用于次只传送少量数据、对可靠性要求不高的应用环境。
### 一个页面从输入URL到页面加载显示完成，这个过程中都发生了什么？
整个过程可分为4个步骤。
- 当发送一个URL请求时，不管这个URL是Web页面的URL还是Web页面上毎个资源的URL，浏览器都会开启一个线程来处理这个请求，同时在远程DNS服务器上启动一个DNS查询。这能使浏览器获得请求对应的IP地址。
- 浏览器与远程Web服务器通过TCP三次握手协商来建立一个TCPP连接。该握手包括一个同步报文、一个同步-应答报文和一个应答报文，这3个报文在浏览器和服务器之间传递。该握手首先由客户端尝试建立起通信，然后服务器应答并接受客户端的请求，最后由客户端发出已经接受该请求的报文。
- 一旦TCP/IP连接建立，浏览器会通过该连接向远程服务器发送HTTP的GET请求。远程服务器找到资源并使用HTTP响应返回该资源，值为200的HTTP响应状态码表示一个正确的响应
- 此时web服务器提供资源服务，客户端开始下载资源。请求返回后，便进入了浏览器端模块。浏览器会解析HTML生成 DOM Tree，其次会根据CSS生成CSS规则树，而 JavaScript又可以根据 DOM API操作DOM。
### 网络分层模型有哪七层？
七层分别是
>应用（ Application）层: 允许访问OSI环境的手段。
表示（ Presentation）层: 对数据进行翻译、加密和压缩。
会话（ Session）层: 建立、管理和终止会话。
传输（ Transport）层: 提供端到端的可靠报文传递和错误恢复。
网络（ Network）层: 负责数据包从源到宿的传递和网际互联。
数据链路（Link）层: 将比特组装成帧并实现点到点的传递。
物理（ Physical）层: 通过媒介传输比特，确定机械及电气规范。

### 网络七层模型中，你所熟知的协议有哪些？
有以下几种协议。
- ICMP，即因特网控制报文协议。它是TCP/IP协议族的一个子协议，用于在IP主机、路由器之间传递控制消息。

- TFTP，即TCPP协议族中一个用来在客户机与服务器之间进行简单文件传输的协议，提供不复杂、开销不大的文件传输服务。

- HTTP，即超文本传输协议，是一个属于应用层的面向对象的协议，由于其简捷快速的方式，适用于分布式超媒体信息系统。

- DHCP，即动态主机配置协议，是一种让系统得以连接到网络并获取所需要配置参数的手段。

### 304缓存的原理。
服务器首先为请求生成ETag，服务器可在稍后的请求中，使用它来判断页面是否已经修改。本质上，客户端通过将该记号传回服务器要求服务器验证其（客户端）是否缓存。
304是HTTP状态码，服务器用它来标识这个文件没有修改，不返回内容，浏览器在接收到个状态码后，会使用浏览器已缓存的文件。
客户端请求页面A。服务器返回页面A，并给A加上一个ETag。客户端展现该页面，并将页面连同ETag一起缓存。
客户端再次请求页面A，并将上次请求时服务器返回的ETag起传递给服务器。
服务器检查该ETag，并判断岀该页面自上次客户端请求之后还未被修改，直接返回响应304（未修改一 Not modified）和一个空的响应体。
### 什么是Etag？
当发送一个服务器请求时，浏览器首先会进行缓存过期判断。浏览器根据缓存过期时间判断缓存文件是否过期若没有过期，则不向服务器发送请求，直接使用缓存中的结果。
此时，我们在浏览器控制台中可以看到200 OK（ from cache），这种情况就是完全使用缓存，浏览器和服务器没有任何交互。
若已过期，则向服务器发送请求。此时，请求中会带上文件修改时间和Etag，然后进行资源更新判断。
服务器根据浏览器传过来的文件修改时间，判断自浏览器上一次请求之后，文件是否被修改过。根据Etag，判断文件内容自上一次请求之后，有没有发生变化。
若两种判断的结论都是文件没有被修改过，服务器就不给浏览器发送新的内容，而是直接告诉浏览器，文件没有被修改过，可以继续使用缓存—-304 Not Modified。
此时，浏览器就会从本地缓存中获取请求资源的内容，这种情况叫协议缓存，浏览器和服务器之间有一次请求交互。
若修改时间或文件内容判断中有任意一个没有通过，则服务器会受理此次请求，并返回新的数据注意，只有get请求会被缓存，post请求不会。
### ETag的应用。
Etag由服务器端生成，客户端通过 If-Match或者If-None-Match这个条件判断请求来验证资源是否修改。常见的是使用I-None-Match。请求一个文件的流程如下。
第一次请求时，客户端发起 Http Get请求，以获取一个文件，服务器处理请求，返回文件内容和请求头（包括Eag），并返回状态码200第二次请求时，客户端发起 Http Get请求，以获取一个文件。
注意，这个时候客户端同时发送一个If-None-Match头，这个头的内容就是第一次请求时服务器返回的Etag服务器判断发送过来的Etag和计算出来的Etag是否匹配。
如果If-None-Match为 False，不返回200，返回304，客户端继续使用本地缓存。
如果服务器设置了 Cache-Control:max-age和 Expires，服务器端在完全匹配 If-Modified-Since和 If-None-Match后，即检查完修改时间和Etag之后，才能返回304。
### Expires和 Cache-Control的作用是什么？
Expires要求客户端和服务器端的时间严格同步。HTTP1.1引入Cache-Control来克服 Expires头的限制。如果max-age和 Expires同时出现，则max-age有更高的优先级。
具体代码如下所示。
```js
Cache-Control:no-cache, private, max-age=0
ETag："8b4c-55f16e2e30000"
Expires:Thu, 02 Dec 2027 11:37:56 GMT
Last-Modified:Wed, 29 Nov 2017 03:39:44 GMT
```
### 什么是反向代理？
反向代理（ Reverse Proxy）是指通过代理服务器来接收互联网上的连接请求，然后将请求转发给内部网络上的服务器，并把从服务器上得到的结果返回给互联网上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。